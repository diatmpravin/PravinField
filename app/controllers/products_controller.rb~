require 'csv'

class ProductsController < ApplicationController

	skip_around_filter :shopify_session

	def by_base_sku_and_brand_id    
    if params[:base_sku] && params[:brand_id]
    	@product = Product.find_by_base_sku_and_brand_id(params[:base_sku], params[:brand_id])
    end
    respond_to do |format|
    	if @product
      	format.html { redirect_to @product }
      	format.json { render json: @product }
      else
      	format.html { redirect_to products_url }
      	format.json { render :status => 404, :json => {:error => 'not found'} }
      end
		end
	end
  
  # GET /products
  # GET /products.json
  def index
  	prod_per_page = 400

		if params[:search]
    	@products = Product.search(params[:search]).order('base_sku').page(params[:page]).per(prod_per_page)
    	@search = params[:search]
		elsif params[:base_sku] && params[:brand_id]
			@product = Product.find_by_brand_id_and_base_sku(params[:brand_id], params[:base_sku])
    elsif params[:brand_id] && params[:store_id]    	
    	@brand = Brand.find(params[:brand_id])
    	@store = Store.find(params[:store_id])
    	@products = @store.products.where(:brand_id => params[:brand_id]).page(params[:page]).per(prod_per_page)
    	@title = "#{@brand.name} Brand, #{@store.name} Store"    	
    elsif params[:brand_id]
			@brand = Brand.find(params[:brand_id])
    	@products = Product.where(:brand_id => params[:brand_id]).page(params[:page]).per(prod_per_page)
    	@title = "#{@brand.name} Brand, All Stores"
    elsif params[:store_id]
    	@store = Store.find(params[:store_id])
    	@products = @store.products.page(params[:page]).per(prod_per_page)
    	@title = "All Brands, #{@store.name} Store"
    elsif params[:vendor_id]
    	@vendor = Vendor.find(params[:vendor_id])
    	@products = @vendor.products.page(params[:page]).per(prod_per_page)
    	@title = "All #{@vendor.name} Brands, All Stores"
    else
    	@products = Product.page(params[:page]).per(prod_per_page)
    	@title = "All Brands, All Stores"
    end
    
    respond_to do |format|
    	if @product
     		format.html { redirect_to @product }
     		format.json { render json: @product }
     	else
      	format.html # index.html.erb
      	format.json { render json: @products }
      end
    end
  end

  # GET /products/1
  # GET /products/1.json
  def show
    @product = Product.find(params[:id])

    respond_to do |format|
      format.html # show.html.erb
      format.json { render json: @product }
    end
  end

  # GET /products/new
  # GET /products/new.json
  def new
    @product = Product.new

    respond_to do |format|
      format.html # new.html.erb
      format.json { render json: @product }
    end
  end

  # GET /products/1/edit
  def edit
    @product = Product.find(params[:id])
  end

  # POST /products
  # POST /products.json
  def create
    @product = Product.new(params[:product])

    respond_to do |format|
      if @product.save
        format.html { redirect_to @product, notice: 'Product was successfully created.' }
        format.json { render json: @product, status: :created, location: @product }
      else
        format.html { render action: "new" }
        format.json { render json: @product.errors, status: :unprocessable_entity }
      end
    end
  end

  # PUT /products/1
  # PUT /products/1.json
  def update
    @product = Product.find(params[:id])

    respond_to do |format|
      if @product.update_attributes(params[:product])
        format.html { redirect_to @product, notice: 'Product was successfully updated.' }
        format.json { head :ok }
      else
        format.html { render action: "edit" }
        format.json { render json: @product.errors, status: :unprocessable_entity }
      end
    end
  end

  # DELETE /products/1
  # DELETE /products/1.json
  def destroy
    @product = Product.find(params[:id])
    @product.destroy

    respond_to do |format|
      format.html { redirect_to products_url, notice: 'Product and variants were successfully destroyed.' }
      format.json { head :ok }
    end
  end
  
  def importProductFile 
  	#infile = params[:file].readlines
  	#CSV.open(infile, 'r').each do |row|
  		#User.create(:username => row[0], :email => row[1])
  	#	raise User.create(:id => row[0], :name => row[1], :email =>row[2], :password =>row[3]).inspect
		#end
  
		CSV.parse(params[:file],'r').each do |row|
			raise row[0].inspect
			raise row[3].inspect
  		# assuming the fields in the CSV file are in order npa, nxxFrom, nxxTo, trnk
  		# create and save a Trunk model for each row
  		raise User.create(:id => row[0], :name => row[1], :email =>row[2], :password =>row[3]).inspect
		end
		 
		#parsed_file = CSV.foreach(params[:file],:headers => true) do |row|
		#	raise row.inspect
		#	row = row.to_hash.with_indifferent_access
		#	User.create!(row.to_hash.symbolize_keys)
		#	redirect_to :action => :index 
		#end 
		 
		 	  
  	#if request.post? && params[:file].present?
  	#	infile = params[:file]
  	#	raise File.new(infile).readlines.inspect 		  		
    #  n, errs = 0, []

    #  CSV.parse(infile) do |row|
    #    n += 1  
    #    raise row.shift.strip.inspect              
        #next if n == 1 or row.join.blank? # SKIP: header i.e. first row OR blank row
        #objective = Objective.csv_new(current_user, row) # build_from_csv method will map customer attributes & build new customer record
    #    raise row.to_hash.with_indifferent_access.inspect
		#		raise objective.inspect
    #    if objective.valid? # Save upon valid otherwise collect error records to export
    #      objective.save
    #    else
    #    	row.push objective.errors.full_messages.join(',')
    #     errs << row
    #    end
    #  end
      
      # Export Error file for later upload upon correction
    #  if errs.any?
    #    errFile ="errors_#{Date.today.strftime('%d%b%y')}.csv"
    #    errs.insert(0, Objective.csv_header)
    #    errCSV = CSV.generate do |csv|
    #      errs.each {|row| csv << row}
    #    end
        
    #    send_data errCSV, :type => 'text/csv; charset=iso-8859-1; header=present',:disposition => "attachment; filename=#{errFile}.csv"
        #redirect_to objectives_path, :notice=>"Errors: #{objective.errors.inspect}"
    #  else
    #    redirect_to products_path, :notice=>'Import successful' #GET
    #  end
    #end
  end

end
